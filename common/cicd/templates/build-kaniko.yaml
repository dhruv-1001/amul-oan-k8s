apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: build-with-kaniko
  namespace: argocd
spec:
  serviceAccountName: ci-builder
  entrypoint: build-and-push
  arguments:
    parameters:
      - name: repo_url
      - name: branch
      - name: image_name # e.g., amul-oan-api
      - name: registry_url # e.g., dev-amulmitra.amul.com (internal registry URL)
      - name: tag_strategy # "branch" (commit-sha) or "tag" (git-tag)
  
  templates:
  - name: build-and-push
    inputs:
      parameters:
        - name: repo_url
        - name: branch
        - name: image_name
        - name: registry_url
        - name: tag_strategy
        - name: target_namespace
        - name: target_deployment

    
    steps:
    - - name: get-git-info
        template: git-checkout-check
        arguments:
          parameters:
            - name: repo_url
              value: "{{inputs.parameters.repo_url}}"
            - name: branch
              value: "{{inputs.parameters.branch}}"
            - name: tag_strategy
              value: "{{inputs.parameters.tag_strategy}}"
            - name: registry_url
              value: "{{inputs.parameters.registry_url}}"
            - name: image_name
              value: "{{inputs.parameters.image_name}}"
            - name: target_namespace
              value: "{{inputs.parameters.target_namespace}}"
            - name: target_deployment
              value: "{{inputs.parameters.target_deployment}}"

    
    - - name: build
        template: kaniko-build
        when: "{{steps.get-git-info.outputs.parameters.should_build}} == true"
        arguments:
          parameters:
            - name: repo_url
              value: "{{inputs.parameters.repo_url}}"
            - name: commit_hash
              value: "{{steps.get-git-info.outputs.parameters.commit_hash}}"
            - name: image_tag
              value: "{{steps.get-git-info.outputs.parameters.image_tag}}"
            - name: image_name
              value: "{{inputs.parameters.image_name}}"
            - name: registry_url
              value: "{{inputs.parameters.registry_url}}"
              
    - - name: deploy
        template: kubectl-deploy
        when: "{{steps.get-git-info.outputs.parameters.should_deploy}} == true"
        arguments:
          parameters:
            - name: namespace
              value: "{{inputs.parameters.target_namespace}}"
            - name: deployment
              value: "{{inputs.parameters.target_deployment}}"
            - name: container
              value: "{{inputs.parameters.image_name}}" # Assuming container name matches image name usually, or we add another param
            - name: image
              value: "{{inputs.parameters.registry_url}}/{{inputs.parameters.image_name}}:{{steps.get-git-info.outputs.parameters.image_tag}}"

  - name: kubectl-deploy
    inputs:
      parameters:
        - name: namespace
        - name: deployment
        - name: container
        - name: image
    container:
      image: bitnami/kubectl:latest
      command: [sh, -c]
      args: ["kubectl set image deployment/{{inputs.parameters.deployment}} {{inputs.parameters.container}}={{inputs.parameters.image}} -n {{inputs.parameters.namespace}}"]

  - name: git-checkout-check
    inputs:
      parameters:
        - name: repo_url
        - name: branch
        - name: tag_strategy
        - name: image_name
        - name: registry_url
        - name: target_namespace
        - name: target_deployment

    outputs:
      parameters:
        - name: should_build
          valueFrom:
            path: /tmp/should_build
        - name: commit_hash
          valueFrom:
            path: /tmp/commit_hash
        - name: image_tag
          valueFrom:
            path: /tmp/image_tag
        - name: should_deploy
          valueFrom:
            path: /tmp/should_deploy
    script:
      image: dtzar/helm-kubectl:latest
      command: [sh]
      volumeMounts:
        - name: kaniko-secret
          mountPath: /kaniko/.docker/
      source: |
        REPO="{{inputs.parameters.repo_url}}"
        BRANCH="{{inputs.parameters.branch}}"
        STRATEGY="{{inputs.parameters.tag_strategy}}"
        REGISTRY="{{inputs.parameters.registry_url}}"
        IMAGE="{{inputs.parameters.image_name}}"
        
        echo "Starting check for $REPO ($STRATEGY)..."

        # 1. Determine the Tag we EXPECT
        if [ "$STRATEGY" = "tag" ]; then
          # Robust tag extraction:
          # 1. Sort by version (descending)
          # 2. Filter out dereferenced tags (^{})
          # 3. Take the first result
          # 4. Extract ref name ($2)
          # 5. Strip 'refs/tags/' prefix
          LATEST_TAG=$(git ls-remote --tags --sort=-v:refname "$REPO" | grep -v '\^{}' | head -n 1 | awk '{print $2}' | sed 's|^refs/tags/||')
          if [ -z "$LATEST_TAG" ]; then echo "No tags found"; exit 0; fi
          
          IMAGE_TAG="$LATEST_TAG"
          COMMIT_HASH="$LATEST_TAG"
        else
          # Branch Strategy
          LATEST_SHA=$(git ls-remote "$REPO" "refs/heads/$BRANCH" | awk '{print $1}' | cut -c1-7)
          if [ -z "$LATEST_SHA" ]; then echo "Branch not found"; exit 1; fi
          
          IMAGE_TAG="$BRANCH-$LATEST_SHA"
          COMMIT_HASH="$LATEST_SHA"
        fi

        echo "Identified Hash/Tag: $COMMIT_HASH"
        echo "$COMMIT_HASH" > /tmp/commit_hash
        echo "$IMAGE_TAG" > /tmp/image_tag

        # 2. Check if this image ALREADY EXISTS in Registry
        CHECK_URL="http://$REGISTRY/v2/$IMAGE/manifests/$IMAGE_TAG"
        echo "Checking registry: $CHECK_URL"
        
        AUTH_HEADER=""
        
        if [ -f /kaniko/.docker/config.json ]; then
            AUTH_TOKEN=$(cat /kaniko/.docker/config.json | jq -r --arg reg "$REGISTRY" '.auths[$reg].auth // .auths["https://"+$reg].auth // empty')
            if [ -n "$AUTH_TOKEN" ]; then
                echo "Found credentials for $REGISTRY"
                AUTH_HEADER="-H \"Authorization: Basic $AUTH_TOKEN\""
            else
                echo "No request-matching credentials found for $REGISTRY"
            fi
        fi
        
        # Use eval to handle the quoted header argument properly
        # Send Accept headers to support OCI and Docker v2 manifests
        # Use -L to follow HTTP->HTTPS redirects, -k to allow self-signed/internal certs
        # Use --location-trusted to forward Authorization header to redirected host (HTTP->HTTPS)
        HTTP_CODE=$(eval curl -L --location-trusted -k -s -o /dev/null -w "%{http_code}" $AUTH_HEADER -H \"Accept: application/vnd.docker.distribution.manifest.v2+json, application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.oci.image.manifest.v1+json\" "$CHECK_URL" || echo "000")
        
        if [ "$HTTP_CODE" = "200" ]; then
           echo "Image $IMAGE:$IMAGE_TAG already exists (HTTP 200). Skipping build."
           echo "false" > /tmp/should_build
           
           # Check if we need to deploy (compare with running image)
           TARGET_NS="{{inputs.parameters.target_namespace}}"
           TARGET_DEPLOY="{{inputs.parameters.target_deployment}}"
           EXT_REGISTRY="{{inputs.parameters.registry_url}}"
           
           if [ -n "$TARGET_DEPLOY" ]; then
               echo "Checking current deployment image..."
               CURRENT_IMAGE=$(kubectl get deployment -n "$TARGET_NS" "$TARGET_DEPLOY" -o jsonpath='{.spec.template.spec.containers[?(@.name=="'$IMAGE'")].image}')
               EXPECTED_IMAGE="$EXT_REGISTRY/$IMAGE:$IMAGE_TAG"
               
               echo "Current Deployed Image: $CURRENT_IMAGE"
               echo "Expected Image: $EXPECTED_IMAGE"
               
               if [ "$CURRENT_IMAGE" = "$EXPECTED_IMAGE" ]; then
                   echo "Deployment is already up to date. Skipping deploy."
                   echo "false" > /tmp/should_deploy
               else
                   echo "Deployment needs update. Proceeding with deploy."
                   echo "true" > /tmp/should_deploy
               fi
           else
               # No deployment target specified, so nothing to deploy
               echo "false" > /tmp/should_deploy
           fi
           
        else
           echo "Image not found ($HTTP_CODE). Triggering build."
           echo "true" > /tmp/should_build
           # If we build, we MUST deploy
           echo "true" > /tmp/should_deploy
        fi

  - name: kaniko-build
    inputs:
      parameters:
        - name: repo_url
        - name: commit_hash
        - name: image_tag
        - name: image_name
        - name: registry_url
      artifacts:
        - name: source
          path: /src
          git:
            repo: "{{inputs.parameters.repo_url}}"
            revision: "{{inputs.parameters.commit_hash}}"
    container:
      image: gcr.io/kaniko-project/executor:latest
      args:
        - "--context=dir:///src"
        - "--destination={{inputs.parameters.registry_url}}/{{inputs.parameters.image_name}}:{{inputs.parameters.image_tag}}"
        - "--cache=true"
      volumeMounts:
        - name: kaniko-secret
          mountPath: /kaniko/.docker/
  
  volumes:
    - name: kaniko-secret
      secret:
        secretName: regcred
        items:
          - key: .dockerconfigjson
            path: config.json
